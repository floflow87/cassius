Contexte

Cassius est une app SaaS multi-tenant. L‚Äôarchitecture actuelle est globalement saine (client/, server/, shared/, migrations/), mais le backend commence √† grossir (routes, storage, int√©grations, emails, calendar, documents, flags, etc.).

Objectif : faire un mini rework structurel pour garder le code maintenable, en refactor progressif et sans casser l‚Äôapp.

üéØ Objectifs (priorit√©)

Cr√©er une arborescence modulaire c√¥t√© server/ (modules)

Extraire les briques transverses dans server/lib/

Pr√©parer les traitements async/cron dans server/jobs/

Garder les routes existantes intactes au d√©but, puis migrer progressivement

√âliminer les sources de v√©rit√© multiples autour du sch√©ma DB (√©viter schema.sql en source active)

‚úÖ Contraintes

Aucun breaking change d‚ÄôAPI

M√™me URLs / m√™mes r√©ponses JSON

M√™me auth / m√™me multi-tenant checks

Ajouter des tests simples ou ‚Äúsmoke tests‚Äù (√† minima scripts) pour valider les endpoints critiques

Refactor en ‚Äústrangler pattern‚Äù : on d√©place par petites √©tapes

1) Nouvelle structure √† cr√©er

Cr√©er ces dossiers :

server/
  modules/
    patients/
      routes.ts
      service.ts
      repo.ts
      schemas.ts
      types.ts
    implants/
    operations/
    appointments/
    documents/
    flags/
    notifications/
    integrations/
      google-calendar/
        routes.ts
        service.ts
        client.ts
        schemas.ts
        types.ts
    auth/
      routes.ts
      service.ts
      repo.ts
      schemas.ts
      email.ts
  lib/
    env.ts
    logger.ts
    auth.ts
    supabase.ts
    db.ts
    storage.ts
    resend.ts
    errors.ts
    pagination.ts
  jobs/
    index.ts
    email_outbox.worker.ts
    digests.cron.ts
    google_sync.worker.ts


Notes :

routes.ts = uniquement routing + validation + appel service

service.ts = logique m√©tier (orchestration)

repo.ts = acc√®s DB (drizzle queries)

schemas.ts = zod + DTO d‚Äôinput

lib/ = r√©utilisable partout

jobs/ = async / cron / retry

2) √âtape 1 ‚Äî Refactor minimal (sans d√©placer tout)
2.1 Cr√©er server/lib/env.ts (obligatoire)

Centraliser la lecture des env vars

Ajouter une validation (zod) pour √©viter les env manquantes silencieuses

Exposer ENV + helpers isProd, isStaging, etc.

Les secrets doivent √™tre lus depuis process.env

2.2 Cr√©er server/lib/logger.ts

Logger simple (console) mais structur√©

Ajout de requestId si d√©j√† existant sinon minimal

2.3 Cr√©er server/lib/db.ts

Centraliser l‚Äôinstanciation drizzle + pool

S‚Äôappuyer sur l‚Äôenv actuelle (SUPABASE_DB_URL_DEV/PROD etc.)

Emp√™cher une deuxi√®me ‚Äúsource DB‚Äù (ex: √©viter DATABASE_URL si ce n‚Äôest pas la DB cible)

3) √âtape 2 ‚Äî Router ‚Äúcomposite‚Äù propre

Cr√©er un fichier server/http.ts ou server/app.ts (selon ton setup) :

server/routes.ts devient un agr√©gateur

On garde les routes existantes mais on pr√©pare le split :

Ex :

import patientsRouter from "./modules/patients/routes";
app.use("/api/patients", patientsRouter);


Au d√©but, tu peux faire :

patientsRouter redirige vers les handlers existants (wrappers)

Puis on migre feature par feature

4) √âtape 3 ‚Äî Migration progressive (ordre recommand√©)

Refactor par ‚Äúmorceaux‚Äù (dans cet ordre), en gardant l‚Äôapp fonctionnelle :

documents (car d√©j√† bien isol√©)

integrations/google-calendar

auth + emails (resend / outbox)

notifications (ton prochain gros chantier)

appointments

patients / implants / operations (c≈ìur CRM)

Pour chaque module :

d√©placer les fonctions DB dans repo.ts

d√©placer la logique dans service.ts

routes = validation zod + auth + appel service

5) DB ‚Äî ‚Äúsource de v√©rit√©‚Äù (important)
5.1 Clarifier le sch√©ma

shared/schema.ts = source de v√©rit√© Drizzle

migrations/ = seules migrations officielles

5.2 db/schema.sql

le conserver uniquement comme snapshot/documentation

ne plus l‚Äôutiliser comme source d‚Äô√©volution

Ajouter un README dans /db :

‚ÄúNe pas modifier schema.sql pour la prod‚Äù

‚ÄúUtiliser drizzle migrations‚Äù

6) Jobs / Async (pr√©parer sans impl√©menter lourd)

Cr√©er un syst√®me minimal :

server/jobs/email_outbox.worker.ts : traite PENDING -> SENT/FAILED

server/jobs/digests.cron.ts : stub (pas encore actif)

server/jobs/google_sync.worker.ts : stub (ou d√©placer le sync existant)

Au d√©but :

un setInterval simple en dev

en prod : un endpoint admin ‚Äúrun jobs‚Äù ou Render cron (selon infra)

7) Crit√®res d‚Äôacceptation (non n√©gociables)

L‚Äôapplication compile et tourne

Aucun endpoint ne change (URL + payload)

Les pages principales fonctionnent :

Patients list + patient detail

Implants list + implant detail

Documents

Calendar

Flags affich√©s

Auth + forgot password emails

Ajout d‚Äôun script npm run smoke :

ping /api/health

call 3‚Äì5 endpoints cl√©s avec un user test / token (si possible)

Ajout d‚Äôun document docs/architecture.md d√©crivant la structure

8) Deliverables attendus

Nouvelle arborescence cr√©√©e

server/lib/* en place et utilis√©

Au moins 1 module migr√© compl√®tement (Documents recommand√©)

server/routes.ts devenu agr√©gateur propre

Doc courte dans docs/architecture.md