Prompt â€” Fix page implant lente + layout qui disparaÃ®t

Contexte
La route /patients/:patientId/implants/:id met trÃ¨s longtemps Ã  charger et pendant le chargement le layout complet disparaÃ®t (sidebar + topbar). Il nâ€™y a pas beaucoup de data affichÃ©e, donc il y a probablement un problÃ¨me de rendering/routing (layout unmounted) et/ou un endpoint trop lent (DB/N+1/signed URLs) ou une boucle de fetch.

Objectifs

EmpÃªcher dÃ©finitivement le dÃ©montage du layout lors du chargement de la page implant

Identifier prÃ©cisÃ©ment le goulot (frontend loop vs backend slow query vs signed URLs)

RÃ©duire le temps de chargement de la page implant (TTFB + waterfall)

1) Stabiliser le layout (obligatoire)

Mettre Sidebar + Topbar dans un composant parent AppLayout qui reste montÃ© en permanence.

La page implant doit Ãªtre rendue uniquement dans la zone Main (Outlet/RouterView).

Interdire tout Suspense fallback / loading global au niveau du router ou du layout qui masquerait sidebar/topbar.

VÃ©rifier quâ€™aucun key={pathname} (ou Ã©quivalent) nâ€™est appliquÃ© au layout, ce qui le remonterait Ã  chaque navigation.

Interdire if (loading) return null au niveau page si cela remonte et retire le layout : afficher un loader dans Main.

Acceptance : au chargement de /patients/:patientId/implants/:id, sidebar + topbar restent visibles 100% du temps.

2) Ajouter instrumentation performance (obligatoire)

Backend

Ajouter middleware qui logge durÃ©e de chaque requÃªte :

mÃ©thode + route + status + durÃ©e (ms)

Dans lâ€™endpoint implant, logguer les durÃ©es par bloc :

fetch implant

fetch acte chirurgical liÃ©

fetch patient

fetch ISQ

fetch docs/radios (mÃ©tadonnÃ©es)

gÃ©nÃ©ration signed URLs (si fait)

Frontend

Logger une seule fois par navigation (pas en boucle) :

â€œloading implant pageâ€

â€œloaded implant pageâ€

DÃ©tecter si le fetch est dÃ©clenchÃ© plusieurs fois (loop).

Deliverable : identifier si la lenteur vient du backend (TTFB), du nombre dâ€™appels, ou dâ€™une boucle de fetch.

3) Optimiser lâ€™endpoint implant (quick wins)

Ã‰liminer les N+1 queries :

regrouper les requÃªtes (IN / JOIN) au lieu de boucler

Ne pas gÃ©nÃ©rer toutes les signed URLs au chargement :

retourner uniquement les mÃ©tadonnÃ©es docs/radios

gÃ©nÃ©rer la signed URL uniquement quand lâ€™utilisateur ouvre le viewer ou clique tÃ©lÃ©charger

RÃ©duire le payload : renvoyer un â€œimplantDetailâ€ minimal (pas tout le patient + tout lâ€™historique)

Ajouter pagination sur docs/radios (limit 10â€“20)

Acceptance : page implant charge rapidement avec un payload lÃ©ger, puis charge le reste Ã  la demande.

4) VÃ©rifier les indexes DB (si TTFB Ã©levÃ©)

VÃ©rifier index sur :

surgeries(patient_id, performed_at)

surgery_implants(surgery_id)

patient_documents(patient_id, category, created_at)

isq_measurements(implant_id, measured_at)

Ajouter migrations si manquants.

5) Loader / skeleton (perceived performance)

Ajouter un ImplantPageSkeleton dans Main pendant le chargement :

titre, cards, bloc ISQ, bloc docs

Aucun Ã©cran blanc.

5) Le truc Ã  vÃ©rifier en premier (le plus â€œcoupableâ€)

Si tu as Ã§a quelque part, câ€™est quasi sÃ»r que Ã§a dÃ©monte le layout :

key={location.pathname} sur AppLayout ou un parent

<Suspense fallback={<FullPageLoader/>}> autour du router/layout

if (loading) return null; dans un composant haut placÃ©

ğŸ‘‰ Dis Ã  Replit/au dev de chercher ces patterns.